Pointer
--------

Address of operator (&)
-----------------------
- uniary operator
- operand must be name of the variable
- give address number of that variable
- also called referencing operator


Indirection operator (*)
-------------------------
- uniary operator
- operand must be address of the variable
- give data of the variable at that memory locations
- also called de-referencing operator

```cpp
    int x=100;        
    cout<<x<<"\n";    // 100
    cout<<&x<<"\n";   // 0x61ff0c
    cout<<*&x;        // 100
```

- Pointer are the variable that contain address of the other variable (int *p=&x)
- Pointer size depends on the system architecture, not the RAM size.
- int *j; is dangerous because it creates a pointer that may contain a random address. Dereferencing it is undefined behavior, which can crash your program or corrupt memory invisibly. The safe alternative is: initialize, use nullptr, use smart pointers, prefer references, and employ sanitizers/tools during development.
- A wild pointer is a pointer that has not been initialized and therefore points to an unknown or random memory address.
- Here j is wild pointer

```cpp
    int x=5,*j;
    *j=500;
    cout<<x<<" "<<j<<"\n";    // 5 0x61ff54
    cout<<*j<<" "<<&x<<"\n";  // 500 0x61ff0c
    cout<<*&j;                // 0x61ff54
```

- How to avoid wild pointer

| Safe Practice           | Example                               |
| ----------------------- | ------------------------------------- |
| Initialize to `nullptr` | `int *p = nullptr;`                   |
| Point to valid variable | `int x; int *p = &x;`                 |
| Use dynamic memory      | `int *p = new int(10);`               |
| Use smart pointer       | `auto p = std::make_unique<int>(10);` |
| Use reference instead   | `void func(int &r);`                  |
| Reset after delete      | `delete p; p = nullptr;`              |
| Check before use        | `if (p) cout << *p;`                  |


```cpp
    int x=5,*j;
    j=&x;
    cout<<x<<" "<<j<<"\n";    // 5 0x61ff0c
    cout<<*j<<" "<<&x<<"\n";  // 5 0x61ff0c
    cout<<*&j;                // 0x61ff0c
```
- Pointer always point to base address (1st byte address) of the variable
- Pointer point the vairbale of the same DT as pointer DT (otherwise unwanted byte access)
- Pointer size is depend on system architechre not on DT (64bit -> 8 bytes) (32bit -> 4 bytes)
- int x=5,*p,**q,***r;
```cpp
int x=5,*p,**q,***r;
    p=&x;
    q=&p;
    r=&q;
    ***r=6;
    cout<<x<<"\n";   // 6
    **q=7;
    cout<<x<<"\n";   // 7
    *p=8;
    cout<<x<<"\n";   // 8
```

Pointer Arithmetic
--------------------
- +,*,/ of two address is not possible but subtraction (-) is possible
- can't *,/ integer with addres but +,- we can do to move forward/backward directions
- Pointer + n = Pointer + sizeof(type of pointer)*n   (internall calculations)
- Why &a>&b ( i decalred b after the a so need to take memory after a memory higher address)
```cpp
    int a=10;
    int b=20;
    int *p,*q;
    p=&a;
    q=&b;
    cout<<"&a : "<<&a<<"\n";  // &a : 0x61ff04
    cout<<"&b : "<<&b<<"\n";  // &b : 0x61ff00
```

```md
# Exact Inner working

High address (100)
|↓↓ Stack ↓↓|
|   Free    |
|↑↑ Heap ↑↑ |
|   Code    |
Low address (0)
```

```md
# For visualization we read like this Memory Layout (0 - 100 bytes) : After Swapping

Low address (0)
|   Code    |
|↓↓ Heap  ↓↓|
|   Free    |
|↑↑ Stack ↑↑ |
High address (100)
```
- RAM is linear strip of bytes(array of bytes) (lower to higher in any direction) (0 to 100)
- Stack, heap, code, globals, and free space are all linear segments along this byte array
- This segments are manged by stack pointer, heap pointer, and OS loader etc.
- Every byte in RAM has a unique numeric address.(not float number address)
- Variable arranged in sequence from higher to lower
```cpp
    int *p,a;
    int b,*q;
    p=&b;
    q=&a;
    // This all arrange in sequence address from higher to lower addresses
    cout<<"&p : "<<&p<<"\n";
    cout<<"&a : "<<&a<<"\n";
    cout<<"&b : "<<&b<<"\n";
    cout<<"&q : "<<&q<<"\n";
    cout<<"p = "<<p<<"\n";
    cout<<"q = "<<q<<"\n";
    cout<<"p+2 = "<<p+2<<"\n";   // giving self block address
    cout<<"q-2 = "<<q-2<<"\n";   // giving self block address
```

- Pointer difference in blocks/bytes
```cpp
    int *p;
    int a=10,b=20;
    int *q;
    p=&a;
    q=&b;
    cout<<"Blocks gap between p and q: :"<<(&p-&q)<<"\n";
    cout<<"Blocks strictly between p and q: :"<<(&p-&q)-1<<"\n";
    cout << "Bytes gap between *p and *q: "<<(char*)&p - (char*)&q<<"\n";    // or (&p-&q)*4
    cout << "Bytes strictly between *p and *q: "<<((char*)&p - (char*)&q) - sizeof(int*); // or ((&p-&q)-1)*4
```